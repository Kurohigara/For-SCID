ВЕРСТКА

1. Что такое DOM? Древовидное представление сайта в виде объетков, вложенных друг в друга.

2. Какая разница между элементами <span> и <div>? div - блочный элемент, span - строковый

3. Какая разница между селекторами идентификаторов и классов в CSS? Разница в том, что идентификатор присваивается только одному элементу, а класс - любому количеству элементов.

4. Как пользоваться медиазапросами в CSS? В основном используют написание в CSS-файле '@media only screen and (max-width: 320px)'. В HTML через LINK, а JS - тоже самое, что и в CSS только нужно прописать " window.matchMedia()"

5. Что такое псевдоклассы в CSS? Псевдокласс — это селектор, который выбирает элементы, находящиеся в специальном состоянии, например, они являются первым элементом своего типа, или на них наведён указатель мыши.

6. Какие есть варианты позиционирования элементов.Какая разница между ними?    
   - relative -> позиционирование относительно самого себя    
   - static -> это значение по умолчанию для каждого элемента страницы    
   - absolut -> помогает размещать элемент страницы там, где мы хотим    
   - fixed -> элемент позиционируется относительно области просмотра или области экрана   
   - sticky -> до прокрутки будет вести себя как обычный, как статический элемент ,но во время прокрутки элемент будет вести себя, будто он зафиксировался в самом верху родительского места
   
7. Что вы знаете о БЭМ? методология именования структурных элементов интерфейса, придуманная Яндексом. 


   Важной определяющей сущностью в именовании селекторов стал блок:
   Полное имя элемента/модификатора формируется так, чтобы из него можно было определить принадлежность данного элемента/модификатора к конкретному блоку.
   По имени модификатора элемента должно быть возможно определить принадлежность данного модификатора к конкретному элементу конкретного блока

  Правила формирования имени БЭМ-сущности

  - Каждая БЭМ-сущность должна иметь свой класс.
  - CSS-свойства для блоков, элементов и модификаторов описываются только через классы.
  - Для разделения слов в именах используется дефис (-).
  - Элемент отделяется от блока двумя подчеркиваниями (__). Модификатор — одним (_).
  - Имена БЭМ-сущностей записываются с помощью цифр и латинских букв в нижнем регистре.
  
8. Какие из инструментов сборки вам знакомы? GULP - это устаревший вариант особенно, когда на рынке есть React, Vue и Anguler. 
  Смысл следующий: мы создаем для системы Gulp некие задания. Т.е. описываем эти задания на языке Javascript. Затем, Gulp просто выполняет
  эти задания в нужной последовательности, так, как мы это прописали. Т.е. Gulp - это просто система по управлению заданиями по веб-разработке.
  Также ее называют task manager. task - задание, manager - управлять.
  
9. какие препроцессоры знаете? Зачем нужны?  
  Sass — самый первый вариант, где не используются фигурные скобки, а всё сделано на отступах, как в Python.
  SCSS — в нём есть фигурные скобки, как в родном CSS, а ещё есть поддержка современных CSS-трюков,
  которые используются в разных браузерах. Этот формат появился после выхода LESS и стал ответом конкуренту.
  LESS. В 2009 году другие программисты показали свою версию препроцессора, основанную на Sass.
  Они взяли за основу чистый CSS-синтаксис и добавили в него возможность использовать все расширения как в Sass.
  Технически это интереснее, чем простой Sass, но нельзя сказать, что это сильно круче, чем тот же SCSS.
  
GIT 

1. как создать новую ветку ? 
Чтобы создать новую ветку в Git необходимо выполнить команду (вместо mybranch укажите название вашей новой ветки): git branch mybranch.

2. что такое merge request?
Merge requests — основной способ внесения изменений в код при использовании GitLab.
Изменения вносятся в код, затем автором изменений создаётся merge request, который затем обсуждается, в котором происходит code review.
  

3. как перейти к нужному коммиту и продолжить работать в нем ? 
Чтобы перейти в уже существующую ветку, используйте ту же команду git checkout, но без добавления флага -b.
Команде нужно передать имя ветки, в которую вы хотите перейти:

JavaScript


4. какие методы запросов к API  знаете ? 
HTTP POST запрос
Мы используем POSTдля создания нового ресурса. Для POSTзапроса требуется тело, в котором вы определяете данные создаваемой сущности.

HTTP GET запрос
Мы используем GETдля чтения или извлечения ресурса. Успешный GETвозвращает ответ, содержащий запрошенную вами информацию.

HTTP-запрос PUT
Мы используем PUTдля изменения ресурса. PUTобновляет весь ресурс данными, которые передаются в основной полезной нагрузке.
Если нет ресурса, соответствующего запросу, он создаст новый ресурс.

5. Чем отличаются PUT- и POST-запросы?
Разница между PUT и POST состоит в том, что PUT является идемпотентным: повторное его применение даёт тот же результат,
что и при первом применении (то есть у метода нет побочных эффектов),
тогда как повторный вызов одного и того же метода POST может иметь такие эффекты, как например, оформление одного и того же заказа несколько раз.

6. Что такое промис?
Промис (promise) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.

7. Какие типы данных знаете ? 
    String : представляет строку
    Number : представляет числовое значение
    BigInt : предназначен для представления очень больших целых чисел
    Boolean : представляет логическое значение true или false
    Undefined : представляет одно специальное значение - undefined и указывает, что значение не установлено
    Null : представляет одно специальное значение - null и указывает на отсутствие значения
    Symbol : представляет уникальное значение, которое часто применяется для обращения к свойствам сложных объектов
    Object : представляет комплексный объект

8. Какие методы преобразования массивов знаете ? 
   Метод map() возвращает новый массив, содержащий трансформированные значения обрабатываемого массива.
   То, как именно они будут трансформированы, задаётся в передаваемой этому методу функции
   
   Метод filter() возвращает массив элементов, проверяя значения которых функция, переданная этому методу, возвратила true.
   
   Метод reduce() возвращает некое значение, представляющее собой результат обработки всех элементов массива.
   
   Метод find() возвращает первый элемент массива, соответствующий заданному критерию. Этот метод, найдя первый подходящий элемент, не продолжает поиск по массиву.
   
   Метод push() позволяет добавлять элементы в конец массива. Он модифицирует массив, и, после завершения работы, возвращает элемент, добавленный в массив.
   
   Метод pop() удаляет из массива последний элемент. Он модифицирует массив и возвращает удалённый из него элемент.
   
   Метод shift() удаляет из массива первый элемент и возвращает его. Он тоже модифицирует массив, для которого его вызывают.
      
      ПОМЕСТИЛ СЮДА САМЫЕ ОСНОВНЫЕ


9. Как сделать плоский массив из вложенного ?
   Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" на указанный уровень depth.

10. Для чего используется оператор "&&"?
   Иными словами, && означает «и то, и другое». Приоритет этого оператора ниже, чем приоритет операторов сравнения,
   поэтому выражение отрабатывает правильно без скобок.

11. Какое значение имеет this?
   This указывает на объект, который выполняет текущий кусок JavaScript-кода.

12. В чем разница между ключевыми словами «var», «let» и «const»?
  Переменные, объявленные при помощи var , имеют глобальную или локальную (в рамках функции) область видимости.
  Если вы объявляете переменные с использованием let или const , их область видимости будет блочной.
  
  Переменные, объявленные при помощи var , могут обновляться и объявляться заново. 
  Использование let позволяет обновлять переменную, но не объявлять заново, а использование const не предполагает ни того, ни другого.
  
  Переменные всех видов поднимаются в верх своей области видимости. Но переменные, объявленные при помощи var , инициализируются как undefined ,
  а объявленные с использованием let или const — не инициализируются.
  
  При помощи var или let можно объявлять переменные без их инициализации, но если вы объявляете переменную при помощи const , 
  она должна инициализироваться при объявлении.
  
13. Что такое async/await?
   «async/await» упрощает работу с промисами (позволяет асинхронный код записывать синхронным способом).

14. Как проверить, является ли значение массивом?
    Метод Array.isArray() возвращает true, если объект является массивом и false, если он массивом не является.

15. Что такое распространение события (Event Propogation)? как остановить всплытие /погружение?  
   Всплытие - Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
    
   Погружение - если есть много элементов, события которых нужно обрабатывать похожим образом, 
   то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.
   Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.
 
 VUE
 
 1. хуки жизненного цикла? 
   Хуки жизненного цикла помогают понять, как работает используемая библиотека. Блоки жизненного цикла позволяют узнавать,
   когда компонент создается, добавляется в модель DOM, обновляется или уничтожается.

2. то такое вычисляемые свойства и когда их нужно использовать? 
   Вычисляемые свойства в Vue JS позволяют получить специфичные, сложные значения, вычисляемые для визуализации.
   Эти значения привязываются к выбранным значениям зависимостей и обновляются только при изменениях в связанном элементе.
   
   Синтаксис вычисляемых свойств.< script> export default {computed: {}}</ script>. Методы и вычисляемые свойства.
   Синтаксис вычисляемых свойств напоминает синтаксис методов. Но вычисляемые свойства намного эффективнее.


3. Что такое Vuex? 
   Vuex — паттерн управления состоянием + библиотека для приложений на Vue.js.
   Он служит централизованным хранилищем данных для всех компонентов приложения с правилами, гарантирующими, 
   что состояние может быть изменено только предсказуемым образом. Vuex интегрируется с официальным расширением


4. Как сделать редирект в Vue Router?
   Переадресация с параметрами
   При этом при переадресации можно передавать параметры:
      <div id="app">
      <router-view></router-view>
      </div>
      <script src="https://unpkg.com/vue@2.7.14/dist/vue.js"></script>
      <script src="https://unpkg.com/vue@2.7.14/dist/vue.js-router/dist/vue-router.js"></script>
      <script>
      const Home = { template: '<h2>Главная</h2>' }
      const Product = { template: '<h2>Товар {{$route.params.id}}</h2>' }
      const NotFound = { template: '<h2>Страница не найдена</h2>' }

      const routes = [
        { path: '/', component: Home },
        { path: '/product/:id', redirect:'/ru/product/:id' },
        { path: '/ru/product/:id', component: Product },
        { path: '/404', component:NotFound },
        { path: '*', redirect: "/404" }
      ];

      const router = new VueRouter({
          mode: 'history',
          routes: routes
      });
      new Vue({
        el: '#app',
        router: router
      })
      </script>
  
  Переадресация с именованный маршрут
  Чтобы проще было управлять переадресацией можно установить редирект на маршрут по определенному имени:
     const routes = [
      { path: '/', component: Home },

      { path: '/product/:id', redirect: {name: 'product'} },
      { path: '/ru/product/:id', component: Product, name:'product' },

      { path: '/404', component:NotFound },
      { path: '*', redirect: "/404" }
     ];
     
  Динамическая переадресация
 Иногда возникает ситуация, когда надо динамически решить, куда выполнять переадресацию. 
 В этом случае можно задать функцию, которая динамически определяет, куда переадресовывать пользователя:
      <div id="app">
        <router-view></router-view>
      </div>
      <script src="https://unpkg.com/vue@2.7.14/dist/vue.js"></script>
      <script src="https://unpkg.com/vue@2.7.14/dist/vue.js-router/dist/vue-router.js"></script>
      <script>
      const Home = { template: '<h2>Главная</h2>' }
      const Product = { template: '<h2>Товар {{$route.params.id}}</h2>' }
      const NotFound = { template: '<h2>Страница не найдена</h2>' }

      const routes = [
        { path: '/', component: Home },
        { path: '/product/:id', redirect: to => {
           if (to.params.id > 10) {
              return '/404'
            } else {
              return '/ru/product/:id'
            }
          }
        },
        { path: '/ru/product/:id', component: Product, name:'product' },
        { path: '/404', component:NotFound },
        { path: '*', redirect: "/404" }
      ];

      const router = new VueRouter({
          mode: 'history',
          routes: routes
      });
      new Vue({
        el: '#app',
        router: router
      })
      </script>
  
